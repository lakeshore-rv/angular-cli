"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// tslint:disable:non-null-operator
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const testing_1 = require("@angular-devkit/schematics/testing");
const path = require("path");
const npm_1 = require("./npm");
describe('Schematic Update', () => {
    const schematicRunner = new testing_1.SchematicTestRunner('@schematics/package-update', path.join(__dirname, '../collection.json'));
    let inputTree;
    beforeEach(() => {
        inputTree = new schematics_1.HostTree(new core_1.virtualFs.test.TestHost({
            '/package.json': `{
        "dependencies": {
          "@angular/core": "4.0.0",
          "@angular/compiler": "4.0.0",
          "rxjs": "5.0.0"
        }
      }`,
        }));
    });
    it('works with a fixed version', done => {
        const rule = npm_1.updatePackageJson(['@angular/core', '@angular/compiler'], '4.1.0', false);
        schematicRunner.callRule(rule, inputTree)
            .toPromise().then(outputTree => {
            const packageJson = JSON.parse(outputTree.read('/package.json').toString());
            expect(packageJson.dependencies['@angular/core']).toBe('4.1.0');
            expect(packageJson.dependencies['@angular/compiler']).toBe('4.1.0');
            expect(packageJson.dependencies['rxjs']).toMatch(/^\^5\.\d+\.\d+$/);
            done();
        }, done.fail);
    });
    it('works with a peer dependencies', done => {
        const rule = npm_1.updatePackageJson(['@angular/compiler'], '4.1.0', false);
        schematicRunner.callRule(rule, inputTree)
            .toPromise().then(outputTree => {
            const packageJson = JSON.parse(outputTree.read('/package.json').toString());
            expect(packageJson.dependencies['@angular/core']).toBe('4.1.0');
            expect(packageJson.dependencies['@angular/compiler']).toBe('4.1.0');
            expect(packageJson.dependencies['rxjs']).toMatch(/^\^5\.\d+\.\d+$/);
            done();
        }, done.fail);
    });
    it('works with a loose version', done => {
        const rule = npm_1.updatePackageJson(['@angular/core', '@angular/compiler'], '~4.1.0', true);
        schematicRunner.callRule(rule, inputTree)
            .toPromise().then(outputTree => {
            const packageJson = JSON.parse(outputTree.read('/package.json').toString());
            expect(packageJson.dependencies['@angular/core']).toBe('~4.1.3');
            expect(packageJson.dependencies['@angular/compiler']).toBe('~4.1.3');
            expect(packageJson.dependencies['rxjs']).toMatch(/^\^5\.\d+\.\d+$/);
            done();
        }, done.fail);
    });
    it('fails with an invalid version', done => {
        const rule = npm_1.updatePackageJson(['@angular/core'], 'babababarbaraann');
        schematicRunner.callRule(rule, inputTree)
            .toPromise().then(() => done.fail('version should not match.'), () => done());
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnBtX3NwZWMuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2VybmllZGF2aXMvQ29kZS9hbmd1bGFyLWNsaS8iLCJzb3VyY2VzIjpbInBhY2thZ2VzL3NjaGVtYXRpY3MvcGFja2FnZV91cGRhdGUvdXRpbGl0eS9ucG1fc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7R0FNRztBQUNILG1DQUFtQztBQUNuQywrQ0FBaUQ7QUFDakQsMkRBQTREO0FBQzVELGdFQUF5RTtBQUN6RSw2QkFBNkI7QUFDN0IsK0JBQTBDO0FBRzFDLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7SUFDaEMsTUFBTSxlQUFlLEdBQUcsSUFBSSw2QkFBbUIsQ0FDN0MsNEJBQTRCLEVBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLG9CQUFvQixDQUFDLENBQzNDLENBQUM7SUFDRixJQUFJLFNBQWUsQ0FBQztJQUVwQixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsU0FBUyxHQUFHLElBQUkscUJBQVEsQ0FBQyxJQUFJLGdCQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUNuRCxlQUFlLEVBQUU7Ozs7OztRQU1mO1NBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTixDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyw0QkFBNEIsRUFBRSxJQUFJLENBQUMsRUFBRTtRQUN0QyxNQUFNLElBQUksR0FBRyx1QkFBaUIsQ0FBQyxDQUFDLGVBQWUsRUFBRSxtQkFBbUIsQ0FBQyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV2RixlQUFlLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUM7YUFDdEMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzdCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUcsQ0FBQyxRQUFRLEVB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QUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2xGLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpub24tbnVsbC1vcGVyYXRvclxuaW1wb3J0IHsgdmlydHVhbEZzIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2NvcmUnO1xuaW1wb3J0IHsgSG9zdFRyZWUsIFRyZWUgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcyc7XG5pbXBvcnQgeyBTY2hlbWF0aWNUZXN0UnVubmVyIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L3NjaGVtYXRpY3MvdGVzdGluZyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgdXBkYXRlUGFja2FnZUpzb24gfSBmcm9tICcuL25wbSc7XG5cblxuZGVzY3JpYmUoJ1NjaGVtYXRpYyBVcGRhdGUnLCAoKSA9PiB7XG4gIGNvbnN0IHNjaGVtYXRpY1J1bm5lciA9IG5ldyBTY2hlbWF0aWNUZXN0UnVubmVyKFxuICAgICdAc2NoZW1hdGljcy9wYWNrYWdlLXVwZGF0ZScsXG4gICAgcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2NvbGxlY3Rpb24uanNvbicpLFxuICApO1xuICBsZXQgaW5wdXRUcmVlOiBUcmVlO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGlucHV0VHJlZSA9IG5ldyBIb3N0VHJlZShuZXcgdmlydHVhbEZzLnRlc3QuVGVzdEhvc3Qoe1xuICAgICAgJy9wYWNrYWdlLmpzb24nOiBge1xuICAgICAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgICAgXCJAYW5ndWxhci9jb3JlXCI6IFwiNC4wLjBcIixcbiAgICAgICAgICBcIkBhbmd1bGFyL2NvbXBpbGVyXCI6IFwiNC4wLjBcIixcbiAgICAgICAgICBcInJ4anNcIjogXCI1LjAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1gLFxuICAgIH0pKTtcbiAgfSk7XG5cbiAgaXQoJ3dvcmtzIHdpdGggYSBmaXhlZCB2ZXJzaW9uJywgZG9uZSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHVwZGF0ZVBhY2thZ2VKc29uKFsnQGFuZ3VsYXIvY29yZScsICdAYW5ndWxhci9jb21waWxlciddLCAnNC4xLjAnLCBmYWxzZSk7XG5cbiAgICBzY2hlbWF0aWNSdW5uZXIuY2FsbFJ1bGUocnVsZSwgaW5wdXRUcmVlKVxuICAgICAgLnRvUHJvbWlzZSgpLnRoZW4ob3V0cHV0VHJlZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShvdXRwdXRUcmVlLnJlYWQoJy9wYWNrYWdlLmpzb24nKSAhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGV4cGVjdChwYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXNbJ0Bhbmd1bGFyL2NvcmUnXSkudG9CZSgnNC4xLjAnKTtcbiAgICAgICAgZXhwZWN0KHBhY2thZ2VKc29uLmRlcGVuZGVuY2llc1snQGFuZ3VsYXIvY29tcGlsZXInXSkudG9CZSgnNC4xLjAnKTtcbiAgICAgICAgZXhwZWN0KHBhY2thZ2VKc29uLmRlcGVuZGVuY2llc1sncnhqcyddKS50b01hdGNoKC9eXFxeNVxcLlxcZCtcXC5cXGQrJC8pO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGRvbmUuZmFpbCk7XG4gIH0pO1xuXG4gIGl0KCd3b3JrcyB3aXRoIGEgcGVlciBkZXBlbmRlbmNpZXMnLCBkb25lID0+IHtcbiAgICBjb25zdCBydWxlID0gdXBkYXRlUGFja2FnZUpzb24oWydAYW5ndWxhci9jb21waWxlciddLCAnNC4xLjAnLCBmYWxzZSk7XG5cbiAgICBzY2hlbWF0aWNSdW5uZXIuY2FsbFJ1bGUocnVsZSwgaW5wdXRUcmVlKVxuICAgICAgICAgICAgICAgICAgICAudG9Qcm9taXNlKCkudGhlbihvdXRwdXRUcmVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShvdXRwdXRUcmVlLnJlYWQoJy9wYWNrYWdlLmpzb24nKSAhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICBleHBlY3QocGFja2FnZUpzb24uZGVwZW5kZW5jaWVzWydAYW5ndWxhci9jb3JlJ10pLnRvQmUoJzQuMS4wJyk7XG4gICAgICAgICAgICAgICAgICAgICBleHBlY3QocGFja2FnZUpzb24uZGVwZW5kZW5jaWVzWydAYW5ndWxhci9jb21waWxlciddKS50b0JlKCc0LjEuMCcpO1xuICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHBhY2thZ2VKc29uLmRlcGVuZGVuY2llc1sncnhqcyddKS50b01hdGNoKC9eXFxeNVxcLlxcZCtcXC5cXGQrJC8pO1xuXG4gICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgfSwgZG9uZS5mYWlsKTtcbiAgfSk7XG5cbiAgaXQoJ3dvcmtzIHdpdGggYSBsb29zZSB2ZXJzaW9uJywgZG9uZSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHVwZGF0ZVBhY2thZ2VKc29uKFsnQGFuZ3VsYXIvY29yZScsICdAYW5ndWxhci9jb21waWxlciddLCAnfjQuMS4wJywgdHJ1ZSk7XG5cbiAgICBzY2hlbWF0aWNSdW5uZXIuY2FsbFJ1bGUocnVsZSwgaW5wdXRUcmVlKVxuICAgICAgLnRvUHJvbWlzZSgpLnRoZW4ob3V0cHV0VHJlZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShvdXRwdXRUcmVlLnJlYWQoJy9wYWNrYWdlLmpzb24nKSAhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIGV4cGVjdChwYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXNbJ0Bhbmd1bGFyL2NvcmUnXSkudG9CZSgnfjQuMS4zJyk7XG4gICAgICAgIGV4cGVjdChwYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXNbJ0Bhbmd1bGFyL2NvbXBpbGVyJ10pLnRvQmUoJ340LjEuMycpO1xuICAgICAgICBleHBlY3QocGFja2FnZUpzb24uZGVwZW5kZW5jaWVzWydyeGpzJ10pLnRvTWF0Y2goL15cXF41XFwuXFxkK1xcLlxcZCskLyk7XG5cbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZG9uZS5mYWlsKTtcbiAgfSk7XG5cbiAgaXQoJ2ZhaWxzIHdpdGggYW4gaW52YWxpZCB2ZXJzaW9uJywgZG9uZSA9PiB7XG4gICAgY29uc3QgcnVsZSA9IHVwZGF0ZVBhY2thZ2VKc29uKFsnQGFuZ3VsYXIvY29yZSddLCAnYmFiYWJhYmFyYmFyYWFubicpO1xuXG4gICAgc2NoZW1hdGljUnVubmVyLmNhbGxSdWxlKHJ1bGUsIGlucHV0VHJlZSlcbiAgICAgIC50b1Byb21pc2UoKS50aGVuKCgpID0+IGRvbmUuZmFpbCgndmVyc2lvbiBzaG91bGQgbm90IG1hdGNoLicpLCAoKSA9PiBkb25lKCkpO1xuICB9KTtcbn0pO1xuIl19