"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const kNanosecondsPerSeconds = 1e9;
const kBenchmarkIterationMaxCount = 10000;
const kBenchmarkTimeoutInMsec = 5000;
const kWarmupIterationCount = 10;
const kTopMetricCount = 5;
function _run(fn, collector) {
    const timeout = Date.now();
    // Gather the first 5 seconds runs, or kMaxNumberOfIterations runs whichever comes first
    // (soft timeout).
    for (let i = 0; i < kBenchmarkIterationMaxCount && (Date.now() - timeout) < kBenchmarkTimeoutInMsec; i++) {
        // Start time.
        const start = process.hrtime();
        fn();
        // Get the stop difference time.
        const diff = process.hrtime(start);
        // Add to metrics.
        collector.push(diff[0] * kNanosecondsPerSeconds + diff[1]);
    }
}
function _stats(metrics) {
    metrics.sort((a, b) => a - b);
    const middle = metrics.length / 2;
    const mean = Number.isInteger(middle)
        ? metrics[middle] : ((metrics[middle - 0.5] + metrics[middle + 0.5]) / 2);
    const total = metrics.reduce((acc, curr) => acc + curr, 0);
    const average = total / metrics.length;
    return {
        fastest: metrics.slice(0, kTopMetricCount),
        slowest: metrics.reverse().slice(0, kTopMetricCount),
        mean,
        average,
    };
}
function benchmark(name, fn, base) {
    it(name + ' (time in nanoseconds)', (done) => {
        process.nextTick(() => {
            for (let i = 0; i < kWarmupIterationCount; i++) {
                // Warm it up.
                fn();
            }
            const reporter = global.benchmarkReporter;
            const metrics = [];
            const baseMetrics = [];
            _run(fn, metrics);
            if (base) {
                _run(base, baseMetrics);
            }
            reporter.reportBenchmark(Object.assign({}, _stats(metrics), { base: base ? _stats(baseMetrics) : null }));
            done();
        });
    });
}
exports.benchmark = benchmark;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmVuY2htYXJrLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9lcm5pZWRhdmlzL0NvZGUvYW5ndWxhci1jbGkvIiwic291cmNlcyI6WyJwYWNrYWdlcy9fL2JlbmNobWFyay9zcmMvYmVuY2htYXJrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBY0EsTUFBTSxzQkFBc0IsR0FBRyxHQUFHLENBQUM7QUFDbkMsTUFBTSwyQkFBMkIsR0FBRyxLQUFLLENBQUM7QUFDMUMsTUFBTSx1QkFBdUIsR0FBRyxJQUFJLENBQUM7QUFDckMsTUFBTSxxQkFBcUIsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBRzFCLGNBQWMsRUFBYyxFQUFFLFNBQW1CO0lBQy9DLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUMzQix3RkFBd0Y7SUFDeEYsa0JBQWtCO0lBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUNULENBQUMsR0FBRywyQkFBMkIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUMsR0FBRyx1QkFBdUIsRUFDbkYsQ0FBQyxFQUFFLEVBQUU7UUFDUixjQUFjO1FBQ2QsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQy9CLEVBQUUsRUFBRSxDQUFDO1FBQ0wsZ0NBQWdDO1FBQ2hDLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbkMsa0JBQWtCO1FBQ2xCLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLHNCQUFzQixHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVEO0FBQ0gsQ0FBQztBQUdELGdCQUFnQixPQUFpQjtJQUMvQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRTlCLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ25DLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM1RSxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMzRCxNQUFNLE9BQU8sR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUV2QyxPQUFPO1FBQ0wsT0FBTyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGVBQWUsQ0FBQztRQUMxQyxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsZUFBZSxDQUFDO1FBQ3BELElBQUk7UUFDSixPQUFPO0tBQ1IsQ0FBQztBQUNKLENBQUM7QUFHRCxtQkFBMEIsSUFBWSxFQUFFLEVBQWMsRUFBRSxJQUFpQjtJQUN2RSxFQUFFLENBQUMsSUFBSSxHQUFHLHdCQUF3QixFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDM0MsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDcEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFCQUFxQixFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM5QyxjQUFjO2dCQUNkLEVBQUUsRUFBRSxDQUFDO2FBQ047WUFFRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsaUJBQWlCLENBQUM7WUFDMUMsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO1lBQzdCLE1BQU0sV0FBVyxHQUFhLEVBQUUsQ0FBQztZQUVqQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2xCLElBQUksSUFBSSxFQUFFO2dCQUNSLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7YUFDekI7WUFFRCxRQUFRLENBQUMsZUFBZSxtQkFDbkIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUNsQixJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFDdkMsQ0FBQztZQUVILElBQUksRUFBRSxDQUFDO1FBQ1QsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUF6QkQsOEJBeUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZGVjbGFyZSBjb25zdCBnbG9iYWw6IHtcbiAgYmVuY2htYXJrUmVwb3J0ZXI6IHtcbiAgICByZXBvcnRCZW5jaG1hcms6IEZ1bmN0aW9uLFxuICB9LFxufTtcblxuXG5jb25zdCBrTmFub3NlY29uZHNQZXJTZWNvbmRzID0gMWU5O1xuY29uc3Qga0JlbmNobWFya0l0ZXJhdGlvbk1heENvdW50ID0gMTAwMDA7XG5jb25zdCBrQmVuY2htYXJrVGltZW91dEluTXNlYyA9IDUwMDA7XG5jb25zdCBrV2FybXVwSXRlcmF0aW9uQ291bnQgPSAxMDtcbmNvbnN0IGtUb3BNZXRyaWNDb3VudCA9IDU7XG5cblxuZnVuY3Rpb24gX3J1bihmbjogKCkgPT4gdm9pZCwgY29sbGVjdG9yOiBudW1iZXJbXSkge1xuICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKTtcbiAgLy8gR2F0aGVyIHRoZSBmaXJzdCA1IHNlY29uZHMgcnVucywgb3Iga01heE51bWJlck9mSXRlcmF0aW9ucyBydW5zIHdoaWNoZXZlciBjb21lcyBmaXJzdFxuICAvLyAoc29mdCB0aW1lb3V0KS5cbiAgZm9yIChsZXQgaSA9IDA7XG4gICAgICAgaSA8IGtCZW5jaG1hcmtJdGVyYXRpb25NYXhDb3VudCAmJiAoRGF0ZS5ub3coKSAtIHRpbWVvdXQpIDwga0JlbmNobWFya1RpbWVvdXRJbk1zZWM7XG4gICAgICAgaSsrKSB7XG4gICAgLy8gU3RhcnQgdGltZS5cbiAgICBjb25zdCBzdGFydCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgZm4oKTtcbiAgICAvLyBHZXQgdGhlIHN0b3AgZGlmZmVyZW5jZSB0aW1lLlxuICAgIGNvbnN0IGRpZmYgPSBwcm9jZXNzLmhydGltZShzdGFydCk7XG5cbiAgICAvLyBBZGQgdG8gbWV0cmljcy5cbiAgICBjb2xsZWN0b3IucHVzaChkaWZmWzBdICoga05hbm9zZWNvbmRzUGVyU2Vjb25kcyArIGRpZmZbMV0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gX3N0YXRzKG1ldHJpY3M6IG51bWJlcltdKSB7XG4gIG1ldHJpY3Muc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIGNvbnN0IG1pZGRsZSA9IG1ldHJpY3MubGVuZ3RoIC8gMjtcbiAgY29uc3QgbWVhbiA9IE51bWJlci5pc0ludGVnZXIobWlkZGxlKVxuICAgID8gbWV0cmljc1ttaWRkbGVdIDogKChtZXRyaWNzW21pZGRsZSAtIDAuNV0gKyBtZXRyaWNzW21pZGRsZSArIDAuNV0pIC8gMik7XG4gIGNvbnN0IHRvdGFsID0gbWV0cmljcy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3VyciwgMCk7XG4gIGNvbnN0IGF2ZXJhZ2UgPSB0b3RhbCAvIG1ldHJpY3MubGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgZmFzdGVzdDogbWV0cmljcy5zbGljZSgwLCBrVG9wTWV0cmljQ291bnQpLFxuICAgIHNsb3dlc3Q6IG1ldHJpY3MucmV2ZXJzZSgpLnNsaWNlKDAsIGtUb3BNZXRyaWNDb3VudCksXG4gICAgbWVhbixcbiAgICBhdmVyYWdlLFxuICB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBiZW5jaG1hcmsobmFtZTogc3RyaW5nLCBmbjogKCkgPT4gdm9pZCwgYmFzZT86ICgpID0+IHZvaWQpIHtcbiAgaXQobmFtZSArICcgKHRpbWUgaW4gbmFub3NlY29uZHMpJywgKGRvbmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga1dhcm11cEl0ZXJhdGlvbkNvdW50OyBpKyspIHtcbiAgICAgICAgLy8gV2FybSBpdCB1cC5cbiAgICAgICAgZm4oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVwb3J0ZXIgPSBnbG9iYWwuYmVuY2htYXJrUmVwb3J0ZXI7XG4gICAgICBjb25zdCBtZXRyaWNzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY29uc3QgYmFzZU1ldHJpY3M6IG51bWJlcltdID0gW107XG5cbiAgICAgIF9ydW4oZm4sIG1ldHJpY3MpO1xuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgX3J1bihiYXNlLCBiYXNlTWV0cmljcyk7XG4gICAgICB9XG5cbiAgICAgIHJlcG9ydGVyLnJlcG9ydEJlbmNobWFyayh7XG4gICAgICAgIC4uLl9zdGF0cyhtZXRyaWNzKSxcbiAgICAgICAgYmFzZTogYmFzZSA/IF9zdGF0cyhiYXNlTWV0cmljcykgOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=